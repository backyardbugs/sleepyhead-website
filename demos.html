<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Demo Crate</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=Lora:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=5">
</head>
<body>
    <div class="container">
       <aside id="sidebar-container"></aside>
        <main>
            <!-- Breadcrumb / Header -->
            <div style="margin-bottom: 20px;">
                <a href="music.html" style="font-family: var(--font-head); font-size: 0.9em;">&larr; Back to Music</a>
            </div>

            <h1 style="font-family: var(--font-head); border-bottom: 2px solid #fff; padding-bottom: 10px;">The Demo Crate</h1>
            <p style="color:#aaa; font-style:italic;">just garbage, but fun to make you know? - Mac Demarco</p>

            <div id="tape-grid" class="tape-grid">
                <!-- Tapes injected via JS -->
                 <div style="grid-column: 1/-1; text-align:center; color:#666; padding: 20px;">
                    Loading tapes...
                </div>
            </div>
            
        </main>
    </div>

    <!-- THE DEMO TAPE PLAYER -->
    <div id="cassette-player">
        <div class="player-info">
            <strong id="cp-title">Select a tape...</strong>
            <span id="cp-status" style="font-size:0.8em; color:#888; margin-left:10px;"></span>
        </div>
        <div class="player-controls">
            <span id="cp-time" style="margin-right:15px; font-family:monospace;">0:00 / 0:00</span>
            <button id="cp-play">PLAY</button>
            <button id="cp-stop">EJECT</button>
        </div>
        <audio id="audio-demo" preload="none"></audio>
    </div>

    <div id="demo-popup-container"></div>

    <script src="loader.js?v=4"></script>
    <script>
        /* --- DEMO CRATE LOGIC --- */
        document.addEventListener('DOMContentLoaded', function() {
            const tapeGrid = document.getElementById('tape-grid');
            const player = document.getElementById('cassette-player');
            const audio = document.getElementById('audio-demo');
            const cpTitle = document.getElementById('cp-title');
            const cpStatus = document.getElementById('cp-status');
            const cpTime = document.getElementById('cp-time');
            const btnPlay = document.getElementById('cp-play');
            const btnStop = document.getElementById('cp-stop');
            
            // Popup Container
            const popupContainer = document.getElementById('demo-popup-container');
            let popupTimeouts = [];

            // Fetch Demos (with cache busting)
            fetch('data/demos.json?v=' + Date.now())
                .then(response => response.json())
                .then(data => {
                    tapeGrid.innerHTML = ''; // Clear loading text

                    if(data.length === 0) {
                        tapeGrid.innerHTML = '<div style="grid-column:1/-1;">No demos found.</div>';
                        return;
                    }

                    data.forEach(demo => {
                        // Create Tape UI
                        const tape = document.createElement('div');
                        tape.className = 'tape-item';
                        
                        // Random Rotation & Translation for "Messier Crate" look
                        const rotation = (Math.random() * 20 - 10).toFixed(1); // -10deg to +10deg (Messier)
                        const transX = (Math.random() * 20 - 10).toFixed(1);   // -10px to +10px
                        const transY = (Math.random() * 20 - 10).toFixed(1);   // -10px to +10px
                        
                        tape.style.transform = `translate(${transX}px, ${transY}px) rotate(${rotation}deg)`;
                        tape.dataset.initialTransform = tape.style.transform; // Save for drag reset logic if needed
                        
                        tape.innerHTML = `
                            <div class="tape-screw-tl"></div>
                            <div class="tape-screw-tr"></div>
                            <div class="tape-label">
                                <span class="tape-title-text">${demo.title}</span>
                                <span class="tape-date-text">${demo.date}</span>
                            </div>
                            <div class="tape-screw-bl"></div>
                            <div class="tape-screw-br"></div>
                        `;
                        
                        // Click Handler to Load (only if not dragging)
                        let isDragging = false;

                        // DRAG LOGIC
                        tape.addEventListener('mousedown', startDrag);
                        tape.addEventListener('touchstart', startDrag, {passive: false});

                        function startDrag(e) {
                            if (e.target.closest('.player-controls')) return; // Don't drag if clicking buttons (not applicable here but good safety)
                            
                            isDragging = false;
                            const startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                            const startY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
                            
                            // Get current transform values to add to drag
                            const rect = tape.getBoundingClientRect();
                            
                            // We need to calculate offset relative to the tape's center/position
                            // But simpler approach: Use variable to store current xy translation
                            
                            const onMove = (moveEvent) => {
                                isDragging = true;
                                moveEvent.preventDefault(); // Prevent scrolling on touch
                                
                                const currentX = moveEvent.type === 'mousemove' ? moveEvent.clientX : moveEvent.touches[0].clientX;
                                const currentY = moveEvent.type === 'mousemove' ? moveEvent.clientY : moveEvent.touches[0].clientY;
                                
                                const deltaX = currentX - startX;
                                const deltaY = currentY - startY;

                                tape.style.transform = `translate(${parseFloat(transX) + deltaX}px, ${parseFloat(transY) + deltaY}px) rotate(${rotation}deg) scale(1.05)`;
                                tape.classList.add('dragging');
                            };

                            const onStop = () => {
                                document.removeEventListener('mousemove', onMove);
                                document.removeEventListener('mouseup', onStop);
                                document.removeEventListener('touchmove', onMove);
                                document.removeEventListener('touchend', onStop);
                                
                                tape.classList.remove('dragging');
                                
                                // Keep the new position? 
                                // For now, let's SNAP BACK because simple translation inside a grid can get weird with z-index clipping
                                // Or better: Let it stay where you dropped it!
                                // To do that, we need to update transX/transY variables, but they are const in loop scope.
                                // We can just calculate the final transform string.
                                
                                // Actually, let's just let it snap back for "Playful" feel but keep the drag interaction fun?
                                // User asked "drag them around". Usually implies they stay.
                                // But without absolute positioning, they are confined to their grid cell visually if overflow issues occur.
                                // Since .tape-item has position:relative, they will move around visually but take up same space.
                                
                                // Let's Let them stay!
                                // We just leave the style.transform as it was set in onMove.
                                // We need to remove the scale(1.05) though.
                                
                                const currentTransform = tape.style.transform;
                                tape.style.transform = currentTransform.replace('scale(1.05)', '');
                            };

                            document.addEventListener('mousemove', onMove);
                            document.addEventListener('mouseup', onStop);
                            document.addEventListener('touchmove', onMove, {passive: false});
                            document.addEventListener('touchend', onStop);
                        }
                        
                        // Separate Click vs Drag
                        tape.addEventListener('click', (e) => {
                            if (!isDragging) {
                                loadTape(demo);
                            }
                        });

                        tapeGrid.appendChild(tape);
                    });
                })
                .catch(err => {
                    console.error('Error loading demos:', err);
                    tapeGrid.innerHTML = 'Error loading tapes.';
                });

            // Player Logic
            function loadTape(demo) {
                player.classList.add('active');
                cpTitle.textContent = demo.title;
                cpStatus.textContent = "Loading...";
                
                // Reset Popups
                popupContainer.innerHTML = '';
                popupTimeouts.forEach(t => clearTimeout(t));
                popupTimeouts = [];

                // Just incase it's a relative path from json
                audio.src = demo.url; 
                
                // ERROR HANDLING
                audio.onerror = function() {
                    let errCode = audio.error ? audio.error.code : 'UNKNOWN';
                    let errMsg = "";
                    switch(errCode) {
                        case 1: errMsg = "Aborted"; break;
                        case 2: errMsg = "Network Error"; break;
                        case 3: errMsg = "Decode Error"; break;
                        case 4: errMsg = "Src Not Supported (Likely 404 or Wrong Format)"; break;
                        default: errMsg = "Unknown";
                    }
                    console.error("Audio Load Error", audio.error);
                    
                    // Diagnostic
                    if (errCode === 4) {
                        cpStatus.innerHTML = `<span style="color:#ff5555">Checking file...</span>`;
                        fetch(audio.src, { method: 'HEAD' })
                        .then(res => {
                            if (res.ok) {
                                cpStatus.innerHTML = `<span style="color:#ff5555">Error: Format check failed (${res.headers.get('content-type')})</span>`;
                            } else {
                                cpStatus.innerHTML = `<span style="color:#ff5555">Error: File not found (${res.status}) <br> Url: ${audio.src}</span>`;
                            }
                        })
                        .catch(e => {
                             cpStatus.innerHTML = `<span style="color:#ff5555">Error: Network Check Failed</span>`;
                        });
                    } else {
                        cpStatus.innerHTML = `<span style="color:#ff5555">Error: ${errMsg} (${errCode})</span>`;
                    }
                };

                audio.load();
                
                // Auto play
                audio.play().then(() => {
                    cpStatus.textContent = "Playing";
                    btnPlay.textContent = "PAUSE";

                    // Trigger Popup(s) if note exists
                    if (demo.note) {
                        // Normalize to array
                        const notes = Array.isArray(demo.note) ? demo.note : [demo.note];
                        
                        let delay = 1000; // Start delay
                        
                        notes.forEach(text => {
                            // Calculate reading time for delay of NEXT message? 
                            // Or just fixed staggering? Let's do fixed + slight length-based.
                            
                            const t = setTimeout(() => {
                                createBubble(text);
                            }, delay);
                            popupTimeouts.push(t);

                            // Increase delay for next message
                            // Base 2s + 50ms per character
                            delay += 2000 + (text.length * 30); 
                        });
                    }

                }).catch(e => {
                    console.log("Auto-play prevented", e);
                    cpStatus.textContent = "Ready";
                    btnPlay.textContent = "PLAY";
                });
            }

            function createBubble(text) {
                const bubble = document.createElement('div');
                bubble.className = "demo-note-bubble";
                bubble.innerHTML = text; // Changed to innerHTML to support links
                popupContainer.appendChild(bubble);

                // Trigger animation
                // Slight delay to ensure DOM paint
                requestAnimationFrame(() => {
                    bubble.classList.add('visible');
                });
            }

            // Play/Pause Toggle
            btnPlay.addEventListener('click', () => {
                if (audio.paused) {
                    audio.play();
                    btnPlay.textContent = "PAUSE";
                    cpStatus.textContent = "Playing";
                } else {
                    audio.pause();
                    btnPlay.textContent = "PLAY";
                    cpStatus.textContent = "Paused";
                }
            });

            // Stop/Eject
            btnStop.addEventListener('click', () => {
                audio.pause();
                audio.currentTime = 0;
                player.classList.remove('active');
                cpStatus.textContent = "Stopped";
                
                // Hide Popups
                popupContainer.innerHTML = '';
                popupTimeouts.forEach(t => clearTimeout(t));
                popupTimeouts = [];
            });

            // Time Update
            audio.addEventListener('timeupdate', () => {
                const current = formatTime(audio.currentTime);
                const duration = formatTime(audio.duration || 0);
                cpTime.textContent = `${current} / ${duration}`;
            });

            // Loop functionality (optional, maybe specific to certain demos?)
            audio.addEventListener('ended', () => {
                 btnPlay.textContent = "PLAY";
                 cpStatus.textContent = "Finished";
            });

            function formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m}:${s < 10 ? '0' : ''}${s}`;
            }
        });
    </script>
</body>
</html>